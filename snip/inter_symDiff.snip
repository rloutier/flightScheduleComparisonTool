A NE PAS SUIVRE :-) ici, on ajoute TOUT pour ensuite supprimer petit à petit; dans notre
cas, où on imagine la diff sym minuscule, c'est très sous optimal.
L'autre approche de n'ajouter QUE ce qu'il faut est + efficace; on le fait en 2 passes, et
c'est bon!
	add s1 (si PAS dans s2)
	add s2 (si PAS dans s1)

----------------- DIFF SYM ----------------------------

public static <T> Set<T> symmetricDifferenceJava8(final Set<T> setOne, final Set<T> setTwo) {
    Set<T> result = new HashSet<>(setOne);
    setTwo.stream().filter(not(resultSet::add)).forEach(resultSet::remove);
    return result;
}

public static <T> Set<T> symmetricDifference(final Set<T> setOne, final Set<T> setTwo) {
    Set<T> result = new HashSet<T>(setOne);
    for (T element : setTwo) {
        if (!result.add(element)) {
            result.remove(element);
        }
    }
    return result;
}

public static <T> Predicate<T> not(Predicate<T> t) {
    return t.negate();
}



---------- INTERSECTION -------
Set<String> intersection = set1.stream()
    .filter(set2::contains)
    .collect(Collectors.toSet());

---------- INTERSECTION -------
Set<String> s1;
Set<String> s2;
s1.retainAll(s2); // s1 now contains only elements in both sets

----------- MATHS ---------
Ia=[a_s;a_e]  
Ib=[b_s;b_e]  

if ( a_e<b_s or b_e<a_s)   return VIDE
else                       return [max(a_s,b_s); min(a_e,b_e)] 


